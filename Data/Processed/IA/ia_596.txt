Can you explain this c code to me? It is part of xv6. // Create PTEs for linear addresses starting at la that refer to // physical addresses starting at pa. la and size might not // be page-aligned. static int mappages(pde_t *pgdir, void *la, uint size, uint pa, int perm) {  char *a, *last;  pte_t *pte;    a = PGROUNDDOWN(la);  last = PGROUNDDOWN(la + size - 1);  for(;;){  pte = walkpgdir(pgdir, a, 1);  if(pte == 0)  return -1;  if(*pte & PTE_P)  panic("remap");  *pte = pa | perm | PTE_P;  if(a == last)  break;  a += PGSIZE;  pa += PGSIZE;  }  return 0; }

This is a function  mappages  that creates page table entries (PTEs) in a page directory  pgdir  for a range of linear addresses starting at  la  and of size  size , mapping them to physical addresses starting at  pa  with the specified permissions  perm . Here's a line-by-line explanation of the function: The function takes a pointer to a page directory  pgdir , a starting virtual address  la , a size  size , a starting physical address  pa , and permission bits  perm . a  is set to the page-aligned address of  la  using  PGROUNDDOWN  macro which rounds down a given address to the nearest page boundary.  last  is set to the page-aligned address of the last byte in the range. The function enters a loop that maps each page in the range. It first calls  walkpgdir  function with the page directory,  a , and a flag indicating that a new PTE should be allocated if it doesn't exist. If  walkpgdir  returns 0, indicating that it failed to allocate a new PTE, the function returns -1. If the PTE already exists (indicated by the  PTE_P  bit), it means that the same virtual address is being mapped to two different physical addresses, which is not allowed. The function panics and halts the system. The function sets the page table entry to the physical address  pa , the permission bits  perm , and the  PTE_P  bit to indicate that the mapping is valid. If the current page is the last page in the range, the function breaks out of the loop. Otherwise, it increments  a  and  pa  by the page size and continues the loop. The function returns 0 to indicate success.

Does every process in xv6 has page table of their own?