{'user': 'Anonymous', 'message': 'I want to create filter related to FittedModel in WalkForward admin ``` class FittedModel(TimeStampedModel):  """  This model stores the fitted model.  """  class Type(models.TextChoices):  BACKTEST = \'backtest\', __("Backtest")  FORECAST = \'forecast\', __("Forecast")  ai_model = models.ForeignKey(AIModel, on_delete=models.CASCADE)  name = models.CharField(max_length=255)  # type of the fitted model. backtest or forecast  type = models.CharField(max_length=255, choices=Type.choices, null=False, default=Type.BACKTEST)  # we can store train_start, train_end, model version, feature version, etc. in this field  metadata = models.JSONField(verbose_name="Meta Data", blank=True, null=True)  # store training states  fit_result = models.JSONField(verbose_name="Fit Results", blank=True, null=True)  # store pickled model  pickle = PickledObjectField(verbose_name="Pickle", null=True)  class Meta:  unique_together = (\'ai_model\', \'name\', \'type\', \'created\')  verbose_name = "Fitted Model"  verbose_name_plural = "Fitted Models"  def __str__(self):  return f"{self.name}({self.id})"  def save_model(self, model):  """  convert ForecasterHDML to bytes and save it to database  """  self.pickle = pickle.dumps(obj=model, protocol=pickle.HIGHEST_PROTOCOL)  self.save()  def load_model(self):  """  convert bytes to ForecasterHDML and return it  """  return pickle.loads(self.pickle) class WalkForward(TimeStampedModel):  """  this serves many to one relationship between FittedModel and WalkForward.  - one walkforward can have multiple fitted_models.  - one fitted_model can have only one walkforward.  """  fitted_models = models.ManyToManyField(FittedModel, through="FittedModelWalkForward", related_name=\'walkforwards\')  # start date of training in walkforward interval  train_start = models.DateTimeField(verbose_name="Training Start Time")  # end date of training in walkforward interval  train_end = models.DateTimeField(verbose_name="Training End Time")  # start date of testing in walkforward interval  test_start = models.DateTimeField(verbose_name="Testing Start Time")  # end date of testing in walkforward interval  test_end = models.DateTimeField(verbose_name="Testing End Time")  class Meta:  verbose_name = "Walkforward"  verbose_name_plural = "Walkforwards"  ordering = [\'-test_end\', \'test_end\']  # def name(self):  # return f"{self.test_start} - {self.test_end}"  def __str__(self):  return f"WalkForward (Train: {self.train_start.strftime(\'%Y-%m-%d\')} to " \\  f"{self.train_end.strftime(\'%Y-%m-%d\')}, " \\  f"Test: {self.test_start.strftime(\'%Y-%m-%d\')} to " \\  f"{self.test_end.strftime(\'%Y-%m-%d\')})" class FittedModelWalkForward(models.Model):  fitted_model = models.ForeignKey(FittedModel, on_delete=models.CASCADE)  walk_forward = models.ForeignKey(WalkForward, on_delete=models.CASCADE)  class Meta:  verbose_name = "Fitted Model Walkforward"  verbose_name_plural = "Fitted Model Walkforwards" ```'}
{'user': 'Chat GPT',