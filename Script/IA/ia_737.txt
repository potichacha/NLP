{'user': 'Anonymous', 'message': '#pragma once #include  #include  /***CHANGE THIS VALUE TO YOUR LARGEST KCAS SIZE ****/ #define MAX_KCAS 6 // at most 6 in erase() /***CHANGE THIS VALUE TO YOUR LARGEST KCAS SIZE ****/ #include "../kcas/kcas.h" using namespace std; class ExternalKCAS { private:   struct Node {  int key;  casword left;  casword right;  casword marked;  bool isLeaf() {  bool result = (left == NULL);  assert(!result || right == NULL);  return result;  }  bool isParentOf(Node *other) {  return (left == other || right == other);  }  };  struct SearchRecord {  Node * gp;  Node * p;  Node * n;    SearchRecord(Node * _gp, Node * _p, Node * _n)  : gp(_gp), p(_p), n(_n) {  }  };  volatile char padding0[PADDING_BYTES];  const int numThreads;  const int minKey;  const int maxKey;  volatile char padding1[PADDING_BYTES];  Node *root;  volatile char padding2[PADDING_BYTES]; public:  ExternalKCAS(const int _numThreads, const int _minKey, const int _maxKey);  ~ExternalKCAS();  long compareTo(int a, int b);  bool contains(const int tid, const int & key);  bool insertIfAbsent(const int tid, const int & key); // try to insert key; return true if successful (if it doesn\'t already exist), false otherwise  bool erase(const int tid, const int & key); // try to erase key; return true if successful, false otherwise    long getSumOfKeys(); // should return the sum of all keys in the set  void printDebuggingDetails(); // print any debugging details you want at the end of a trial in this function private:  auto search(const int tid, const int & key);  auto createInternal(int key, Node * left, Node * right);  auto createLeaf(int key);  void freeSubtree(const int tid, Node * node);  long getSumOfKeysInSubtree(Node * node); }; auto ExternalKCAS::createInternal(int key, Node *left, Node *right) {  Node *node = new Node();  node->key = key;  node->left.setInitVal(left);  node->right.setInitVal(right);  node->marked.setInitVal(false);  return node; } auto ExternalKCAS::createLeaf(int key) {  return createInternal(key, NULL, NULL); } ExternalKCAS::ExternalKCAS(const int _numThreads, const int _minKey, const int _maxKey)  : numThreads(_numThreads), minKey(_minKey), maxKey(_maxKey) {   auto rootLeft = createLeaf(minKey - 1);  auto rootRight = createLeaf(maxKey + 1);  root = createInternal(minKey - 1, rootLeft, rootRight); } ExternalKCAS::~ExternalKCAS() {  freeSubtree(0, root); } inline long ExternalKCAS::compareTo(int a, int b) {  return ((long) a - (long) b); } inline auto ExternalKCAS::search(const int tid, const int & key) {  Node * gp;  Node * p = NULL;  Node * n = root;  while (!n->isLeaf()) {  gp = p;  p = n;  n = (key <= n->key) ? n->left : n->right;  }  return SearchRecord(gp, p, n); } bool ExternalKCAS::contains(const int tid, const int & key) {   assert(key <= maxKey);  auto rec = search(tid, key);  return (rec.n->key == key); } bool ExternalKCAS::insertIfAbsent(const int tid, const int & key) {  assert(key > minKey - 1 && key >= minKey && key <= maxKey &&